#!/bin/bash

. ~/lib/bash/util

# Build a list of allocation sites with the power of objdump.
# We record them as the string inside the < >
# i.e. <symname+0xoffset>, without the < >.

# HACK 1: to make this work for llvm, we just use gold to generate
# a native file with DWARF info, 

# HACK 2: to handle synonymy, 
# for each allocation site's output line,
# we append a list of the synonyms. (FIXME: not impl'd yet)

# HACK 3: we really ought to deal with qualifiers like const. FIXME.

case $(basename "$0") in
    (dumpallocs)
        outputstyle="tab"
        ;;
    (*)
        outputstyle="punc"
        ;;
esac

. ~/lib/bash/util
. $(dirname "$0")/debug-funcs.sh

filetype="$( file -bi "$1" )"
case "$filetype" in
    (application/x-object*)
        inputfile="$1"
    ;;
    (application/x-executable*)
        inputfile="$1"
    ;;
    (application/octet-stream*|application/x-archive*)
        # probably an LLVM bitcode file
        llvm_nm_output="$( llvm-nm "$1" 2>/dev/null )"
        if [[ -n "$llvm_nm_output" ]]; then
            # yes, bitcode. So make a temporary file
            inputfile="$(mktemp)"
            echo "Using temporary object file: $inputfile" 1>&2
            ld -r --plugin LLVMgold.so -o "$inputfile" toy.o || \
            (echo "Error converting LLVM bitcode to native object." 1>&2; false) || exit 1
        else
            # actually, not bitcode; roll with it
            inputfile="$1"
        fi
    ;;
    (*) echo "Error: unrecognised file type $filetype" 1>&2; exit 1
    ;;
esac

line_regexp='^[0-9a-f]* <([^>]*)>'
alloc_site_regexp="${line_regexp}.*"'call.*alloc'

case "$( file "$inputfile" | grep reloc )" in
    ('')
        # not relocatable
        disassembly_opts="-Rd"
        ;;
    (*)
        # relocatable
        disassembly_opts="-rd"
        ;;
esac

apply_relocs () {
    # This is a filter for objdump output that 
    # for each disassembly line,
    # if it is followed by one or more relocs,
    # will merge that reloc info into the line. 
    # We do it in the most stupid way possible: 
    # delete newlines preceding reloc info
    tr '\n' '\f' | sed 's/\f\([[:blank:]]*[0-9a-f]\+: R\)/\1/g' | tr '\f' '\n'
}

allocation_sites="$( objdump --prefix-addresses ${disassembly_opts} "$inputfile" | \
apply_relocs | \
egrep "$alloc_site_regexp" | \
sed -r "s/${alloc_site_regexp}.*/\1/" )" #"

# read the whole objdump in, to avoid re-disassembling
objdump_output="$( objdump --line-numbers --prefix-addresses ${disassembly_opts} -S "$inputfile" | \
apply_relocs )"

echo "Found allocation sites: " 1>&2
echo "$allocation_sites" 1>&2

# HACK: sometimes our gnu_debuglink section is wrong, i.e. does not reflect
# the location of the debug info, e.g. according to Debian policy where
# the debug info is moved into /usr/lib/debug but the debuglink is stuck
# with the same-directory path (i.e. plain filename) that was correct when
# stripping occurred during the build process. 

while read sym offset; do
    # Now use the power of objdump -S to get the source line for that alloc.
    # 1, Build a regexp that will re-locate the current alloc site.
    regexp="<$( escapefn_eregexp "$sym" )\+$( escapefn_eregexp "$offset")>"
    echo "regexp: $regexp" 1>&2
    # 2. Grab that and 10 lines of pre-context, 
    # which hopefully will include the allocating source line
    # FIXME: to optimise, chomp forward from previous match
    # ... using a temporary file and tail -n+k
    context="$( echo "$objdump_output" | egrep -B30 "$regexp" )" #"
    #echo "context: $context" 1>&2
    # 2a. Narrow that context to the last objdump-printed source line.
    # Remember the file/line pair
    with_file_line_header="$( echo "$context" | tac | sed -r '/^\/.*:[0-9]+$/ q' | tac )"
    # If we didn't hit a source header line,
    # what we read next will be garbage, so grep for something that matches the pattern
    file_line_header="$( echo "$with_file_line_header" | grep '^/.*:[0-9]+$' | head -n1 )"
    if [[ -z "$file_line_header" ]]; then 
        echo "Warning: skipping ${sym}+${offset}" 1>&2
        continue
    fi
    filename="$( echo "$file_line_header" | sed 's/:[0-9]\+$//' )"
    line_number="$( echo "$file_line_header" | sed 's/.*:\([0-9]\+\)$/\1/' )"
    context_min="$( echo "$with_file_line_header" | tail -n+2 )"
    echo "context_min: $context_min" 1>&2
    # 3. Filter out non-source lines., and collapse to a single line
    source="$( echo "$context_min" | egrep -v "$line_regexp" | tr '\n' ' ' )" #"
    #echo "source: $source" 1>&2
    # 3a. collapse to a single line
    source_oneline="$( echo "$source" | tr '\n' ' ' )"
    echo "source_oneline: $source_oneline" 1>&2
    # 4. Get the first ident following the last occurrence of "new" or "sizeof"
    token="$( echo "$source_oneline" | \
    egrep '(new|sizeof)([^0-9a-z_]|$)' | \
    sed -r 's/.*(new|sizeof)([^0-9a-zA-Z_]|$)/\2/' | \
    sed -r 's/[^0-9a-zA-Z_]*([a-zA-Z0-9_ \*]+).*/\1/' | tr -s '[:blank:]' ' ' )" #"
    echo "token: $token" 1>&2
    # 5. Print the token and the site
    echo "Guessed that site <${sym}+${offset}> allocated: ${token}" 1>&2
    case "$outputstyle" in
        (tab)
            echo "${sym}"$'\t'"${offset}"$'\t'"${filename}"$'\t'"${line_number}"$'\t'"${token:-\$FAILED\$}"$'\t'"${source_oneline}"
            ;;
        (punc)
            echo "<${sym}+${offset}> @${filename}:${line_number}"$'\t'"${token:-\$FAILED\$}"
            ;;
        (*)
            echo "<${sym}+${offset}> @${filename}:${line_number}"$'\t'"${token:-\$FAILED\$}"
            ;;
    esac
done <<<"$( echo "$allocation_sites" | sed -r 's/\+(0x[0-9a-f]*)$/ \1/' )" #"
