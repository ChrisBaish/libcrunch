libcrunch is a runtime library, with some toolchain extensions (compiler
wrapper, etc.), for fast dynamic type checking in unsafe languages.
Currently that means mostly C, although languages are fairly pluggable
in the design.

It is based on my other project, liballocs, which you should build (and
probably understand) first. Nevertheless, for the impatient, if you're
on a Debian-based x86-64 GNU/Linux machine with gcc 4.9 or later, you 
can try the following.

$ apt-get install libelf-dev autoconf automake libtool pkg-config \
    autoconf-archive libdwarf-dev ocaml openjdk-7-jre libunwind-dev \
    libboost-{iostreams,regex,serialization,filesystem}1.55-dev
$ git clone https://github.com/stephenrkell/liballocs.git
$ cd liballocs
$ git submodule init
$ git submodule update
$ make -C contrib -jn         # for your favourite n
$ ./autogen.sh
$ . contrib/env.sh 
$ ./configure --prefix=/usr/local
$ make -jn                    # for your favourite n
$ cd ..
$ export LIBALLOCS=`pwd`/liballocs
$ git clone https://github.com/stephenrkell/libcrunch.git
$ cd libcrunch
$ make -jn                    # for your favourite n
$ make -C test

Liballocs models programs during execution in terms of /typed
allocations/. It reifies data types, providing fast access to
per-allocation metadata. Libcrunch extends this with check functions,
thereby allowing assertions such as 

assert(__is_aU(p, &__uniqtype_Widget));

to assert that p points to a Widget, and so on. 

A compiler wrapper inserts these checks automatically at particular
points -- primarily at pointer casts, but also at certain uses of va_arg
(and some other places too obscure to get into here). The effect is to
provide clean error messages on bad pointer casts. Language-wise,
libcrunch slightly narrows standard C, such that all live, allocated
storage has a well-defined type at any moment (cf. C99 "effective type"
which is more liberal).

Also, there's a new bounds checker in the works (see crunchbcc,
crunchbound.ml) that avoids a lot of false positives common to other
bounds checkers. I'm hoping it will become the first really practical
on-by-default bounds checker, but time will tell.

Below there is a slightly out-of-date list of some of the known
limitations. More positively, it really works (if you can build it),
supports lots of nasty C code really quite well, and usually only slows
execution by about 5--35% (more if you turn on bounds checking, though).
You can also run instrumented code without the library loaded, when the
slowdown is usually negligible (again, less so for bounds checks).

An incomplete and rather old TODO follows.


Usability quirks 

- requires manual identification of alloc functions (or rather,
liballocs does)

- check-on-cast is too eager for some C programming styles
    ("trap pointer" mechanism in the works)
    
- higher-order (indirect, pointer-to-function) checks are slightly 
    conservative
    (i.e. a few false positives are possible in these cases)

- plain crunchcc assumes memory-correct execution and checks only
    types (use crunchxcc for bounds checking too; 
    temporal correctness is assumed, i.e. use-after-free can break us)


Limitations of metadata

- no metadata (debug info) for actual parameters passed in varargs
     (need to maintain a shadow stack for this; am working on it)

- no metadata (debug info) for address-taken temporaries
     (significant for C++, but not for C; needs compiler fixes)
     
- sizeof scraping is not completely reliable (but is really not bad)


Current performance quirks

- liballocs's trailer-based heap index implementation causes clownshoes

