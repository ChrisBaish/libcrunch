libcrunch is a runtime library, with some toolchain extensions (compiler
wrapper, etc.), for fast dynamic type checking in unsafe languages.
Currently that means mostly C, although languages are fairly pluggable
in the design.

"Dynamic type checking" mostly means checking pointer casts. There is
limited checking of other things like va_arg and union use; more to add
in due course. More recently, libcrunch has acquired a bounds checker
which promises to be faster and more usable than SoftBound. I'm hoping
it will become the first really practical on-by-default bounds checker,
but time will tell... it is still fairly immature and unevaluated. There
is no temporal memory checking at present, but a GC is on the cards.

All this is build on top of my other project, liballocs, which you
should build (and probably understand) first. Nevertheless, for the
impatient, if you're on a Debian-based x86-64 GNU/Linux machine with gcc
4.9 or later, you can try the following, which is tested on Debian
jessie.

$ apt-get install libelf-dev autoconf automake libtool pkg-config \
    autoconf-archive libdwarf-dev ocaml ocaml-findlib \
    openjdk-7-jre-headless make git g++ gawk libunwind-dev \
    libc6-dev-i386 zlib1g-dev libc6-dbg gdb \
    libboost-{iostreams,regex,serialization,filesystem}1.55-dev
$ git clone https://github.com/stephenrkell/liballocs.git
$ cd liballocs
$ git submodule init
$ git submodule update
$ make -C contrib -jn         # for your favourite n
$ ./autogen.sh
$ . contrib/env.sh
$ ./configure --prefix=/usr/local
$ make -jn                    # for your favourite n
$ cd ..
$ export LIBALLOCS=`pwd`/liballocs
$ sudo mkdir /usr/lib/allocsites # metadata will live here
$ sudo chown root:staff /usr/lib/allocsites
$ sudo chmod g+w /usr/lib/allocsites
$ make -f "$LIBALLOCS"/tools/Makefile.allocsites \
  /usr/lib/allocsites$( readlink -f /lib/x86_64-linux-gnu/libc.so.6 )-types.so
$ git clone https://github.com/stephenrkell/libcrunch.git
$ cd libcrunch
$ make -jn                    # for your favourite n
$ make -C test                # if this succeeds, be amazed
$ frontend/c/bin/crunchcc -o hello /path/to/hello.c  # your code here
$ LD_PRELOAD=`pwd`/lib/libcrunch_preload.so ./hello  # marvel!

Liballocs models programs during execution in terms of /typed
allocations/. It reifies data types, providing fast access to
per-allocation metadata. Libcrunch extends this with check functions,
thereby allowing assertions such as 

assert(__is_aU(p, &__uniqtype_Widget));

to assert that p points to a Widget, and so on. 

A compiler wrapper inserts these checks automatically at particular
points -- primarily at pointer casts, but also at certain uses of va_arg
(and some other places too obscure to get into here). The effect is to
provide clean error messages on bad pointer casts. Language-wise,
libcrunch slightly narrows standard C, such that all live, allocated
storage has a well-defined type at any moment (cf. C99 "effective type"
which is more liberal).

Instrumentation is currently done with CIL. There is also a clang
front-end which is less mature (lacks a bounds checker) but will appear
as a submodule in this tree shortly.

Below there is a slightly out-of-date list of some of the known
limitations. More positively, it really works (if you can build it),
supports lots of nasty C code really quite well, and usually only slows
execution by about 5--35% (more if you turn on bounds checking, though).
You can also run instrumented code without the library loaded, when the
slowdown is usually negligible (again, less so for bounds checks).



Usability quirks 

- requires manual identification of alloc functions (or rather,
liballocs does)

- check-on-cast is too eager for some C programming styles
    ("trap pointer" mechanism in the works)
    
- higher-order (indirect, pointer-to-function) checks are slightly 
    conservative
    (i.e. a few false positives are possible in these cases)

- plain crunchcc assumes memory-correct execution and checks only
    types (use crunchxcc for bounds checking too; 
    temporal correctness is assumed, i.e. use-after-free can break us)


Limitations of metadata

- no metadata (debug info) for actual parameters passed in varargs
     (need to maintain a shadow stack for this; am working on it)

- no metadata (debug info) for address-taken temporaries
     (significant for C++, but not for C; needs compiler fixes)
     
- sizeof scraping is not completely reliable (but is really not bad)


Current performance quirks

- liballocs's trailer-based heap index implementation causes clownshoes

